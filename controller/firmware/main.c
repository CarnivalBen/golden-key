
// CONFIG1
#pragma config FOSC = INTOSC    //  (INTOSC oscillator; I/O function on CLKIN pin)
#pragma config WDTE = OFF        // Watchdog Timer Enable (WDT enabled)
#pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
#pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
#pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
#pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
#pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)

// CONFIG2
#pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
#pragma config PLLEN = ON       // PLL Enable (4x PLL enabled)
#pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
#pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
#pragma config LPBOREN = OFF    // Low Power Brown-out Reset enable bit (LPBOR is disabled)
#pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)

#include <xc.h>
#include <stdio.h>
#include <stdlib.h>
#include "main.h"

volatile union {
    struct {
        unsigned F3 : 1;
        unsigned F2 : 1;
        unsigned F1 : 1;
        unsigned FWD : 1;
        unsigned REV : 1;
        unsigned R1 : 1;
        unsigned R2 : 1;
        unsigned R3 : 1;
    };
    byte shiftData;
} output;

//byte trackSpeed;
byte trainDirection;
//byte pwmCount;
//byte tmrAdjust;

const byte speedPulse[] = { 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, };


const byte speedGap[] = { 
    0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 
    0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 
    0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 
    0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 
    0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 
    0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 
    0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 
    0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 
    0xE, 0xE, 0xE, 0xE, 0xE, 0xE, 0xE, 0xE, 
    0xD, 0xD, 0xD, 0xD, 0xD, 0xD, 0xD, 0xD, 
    0xC, 0xC, 0xC, 0xC, 0xC, 0xC, 0xC, 0xC, 
    0xB, 0xB, 0xB, 0xB, 0xB, 0xB, 0xB, 0xB, 
    0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 
    0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 
    0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 
    0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 
    0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 
    0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 
    0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 
    0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 
    0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0  };

byte pulse = 0x20;
byte gap = 0xFF;
byte phase = 0;


int main(void) {

    CLRWDT();
    
    // Oscillator
    OSCCON = 0b01111010;
    
    // PORT SETUP
    INLVLA = 0;
    ANSELA = 0;
    TRISA0 = 0; // STATUS OUT
    TRISA1 = 0; // LATCH
    TRISA2 = 1; // SPEED POTENTIOMETER IN
    //TRISA3 = 1; // OVERLOAD IN (always input)
    TRISA4 = 0; // DATA OUT
    TRISA5 = 0; // DATA CLK OUT
    ODA1 = 0;
    SLRA1 = 0;
    WPUA = 0;
    RA0 = 1;
    ANSELA = 0b00000100;
    ADCON0 = 0b00001001;
    ADCON1 = 0b01100000;
    ADCON2 = 0b00000000;  
    
    // TIMER0 SETUP    
    OPTION_REG = 0b11010010;
    TMR0 = 0;   
    //pwmCount = 0;
    //tmrAdjust = 0;
    
    // TIMER2 SETUP
    T2CON = 0b00000010;
    TMR2 = 0;
    PR2 = 0;
    
    // INTERRUPT SETUP
    TMR0IE = 0;
    TMR2IE = 1;
    PEIE = 1;
    GIE = 1;
    
    
    while (1) {
        
        updateSpeed();
        
        setShiftReg();
        CLRWDT();
    }
    
}

void __interrupt() isr() {
    
    if (TMR2IE && TMR2IF) {
        TMR2IF = 0;
        
        if (phase == 0) {
            PR2 = gap;
            phase = 1;

            output.FWD = 0;
            output.REV = 0;

        } else {
            PR2 = pulse;
            phase = 0;

            if (trainDirection) {
                output.REV = 0;
                output.FWD = 1;
            } else {
                output.FWD = 0;
                output.REV = 1;
            }        
             
        }        
    }
    
    
//    if (TMR0IE && TMR0IF) {
//        TMR0 = tmrAdjust;
//        TMR0IF = 0;
//        pwmCount++;       
//        
//        if (pwmCount == 0) {
//            if (trainDirection) {
//                output.REV = 0;
//                output.FWD = 1;
//            } else {
//                output.FWD = 0;
//                output.REV = 1;
//            }
//        } else if (pwmCount > trackSpeed) {
//            output.FWD = 0;
//            output.REV = 0;
//        }
//        
//    }
       
    return;
}


void updateSpeed() {
    
    ADCON0bits.GO_nDONE = 1;
    while (ADCON0bits.GO_nDONE);
    
    byte speed = ADRES >> 7;
    
    trainDirection = (ADRESH & 0x80) >> 7;
    
    if (!trainDirection) speed = 255 - speed;         
    
    pulse = speedPulse[speed];
    gap = speedGap[speed];
    
    //trackSpeed = speedAdjust[speed];
    
    if (gap == 0 && TMR2ON == 1) {
        TMR2ON = 0;
        output.FWD = 0;
        output.REV = 0;
        
    } else if (gap != 0 && TMR2ON == 0) {
        PR2 = pulse;
        phase = 0;
        TMR2ON = 1;
    }
       
    
//    if (trackSpeed <= 7) tmrAdjust = 0;
//    else if (trackSpeed == 8) tmrAdjust = 10;
//    else if (trackSpeed == 9) tmrAdjust = 25;
//    else if (trackSpeed == 10) tmrAdjust = 40;
//    else if (trackSpeed == 11) tmrAdjust = 50;
//    else if (trackSpeed == 12) tmrAdjust = 60;
//    else if (trackSpeed == 13) tmrAdjust = 70;
//    else if (trackSpeed == 14) tmrAdjust = 80;
//    else if (trackSpeed == 15) tmrAdjust = 90;
//    else tmrAdjust = 200;
    
    
    output.R3 = 0;
    output.R2 = 0;
    output.R1 = 0;
    output.F1 = 0;
    output.F2 = 0;
    output.F3 = 0;
    if (gap == 12) output.R3 = 1;
    if (gap == 13) output.R2 = 1;
    if (gap == 14) output.R1 = 1;
    if (gap == 15) output.F1 = 1;
    if (gap == 16) output.F2 = 1;
    if (gap == 17) output.F3 = 1;
    
//    if (trainDirection) {        
//        output.R3 = 0;
//        output.R2 = 0;
//        output.R1 = 0;
//        output.F1 = trackSpeed > 0;
//        output.F2 = speed > 85;
//        output.F3 = speed > 170; 
//        
//    } else {
//        output.F3 = 0;
//        output.F2 = 0;
//        output.F1 = 0;
//        output.R1 = trackSpeed > 0;
//        output.R2 = speed > 85;
//        output.R3 = speed > 170;
//        
//    }    
}


void setShiftReg() {
    
    byte buff = output.shiftData;
    byte mask = 0b10000000;

    do {
        
        if (buff & mask) {
            RA4 = 1;
        } else {
            RA4 = 0;
        }
        
        NOP();
        RA5 = 1;
        NOP();
        NOP();
        RA5 = 0;
        NOP();
        
        mask = mask >> 1;
    } while (mask > 0);
    
    RA1 = 1;
    NOP();
    NOP();
    RA1 = 0;
    RA4 = 0;
    RA5 = 0;
    
}
